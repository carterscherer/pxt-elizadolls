<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="Q[05Jz2HyPP-=MH)^NP2" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="wUM,)I]8sXlLA-!Q}:9c"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace ElizaDolls {" line1="" line2="    // In case it gets lost from above (// then %) " line3="    //  % color=&quot;#FE99F8&quot;" line4="" line5="    let pulseMinLocal = 1024;" line6="    let pulseMaxLocal = 0;" line7="    let pulseLocal = 0;" line8="    let pulseMotion = 0.001;" line9="" line10="    //% block=&quot;read beat&quot;" line11="    //% group=&quot;Pulse&quot;" line12="    export function pulseSensorBeat( ) : boolean {" line13="" line14="        pulseLocal = pins.analogReadPin( AnalogPin.P1 );" line15="" line16="        pulseMinLocal += ( 1024 - pulseMinLocal ) * pulseMotion;" line17="        if (pulseLocal &lt; pulseMinLocal )" line18="            pulseMinLocal = pulseLocal;" line19="" line20="        pulseMaxLocal -= pulseMaxLocal * pulseMotion;" line21="        if (pulseLocal &gt; pulseMaxLocal)" line22="            pulseMaxLocal = pulseLocal;" line23="" line24="        let range = pulseMaxLocal - pulseMinLocal;" line25="" line26="        let output = false;" line27="" line28="        if ( range &gt; 0 ) {" line29="            if ( ( pulseLocal - pulseMinLocal ) &gt; 3 * range / 4 )" line30="                output = true;" line31="        }" line32="" line33="        return output;" line34="    }" line35="" line36="    let pulseSensorBpmBeat = false;" line37="    let pulseSensorBpmRunningTime = 0;" line38="    let pulseSensorBpmStore = 0;" line39="" line40="    //% block=&quot;read pulse BPM&quot;" line41="    //% group=&quot;Pulse&quot;" line42="    export function pulseSensorBpm(): number {" line43="        let beat = pulseSensorBeat();" line44="        if ( beat &amp;&amp; ( beat != pulseSensorBpmBeat ) ) {" line45="            let runningTime = input.runningTime();" line46="            pulseSensorBpmStore = 60000 / ( runningTime - pulseSensorBpmRunningTime );" line47="            pulseSensorBpmRunningTime = runningTime;" line48="        }" line49="        pulseSensorBpmBeat = beat;" line50="        return pulseSensorBpmStore;" line51="    }" line52="" line53="    //% block=&quot;read pulse wave&quot;" line54="    //% group=&quot;Pulse&quot;" line55="    export function pulseSensorWave(): number { " line56="        pulseLocal = pins.analogReadPin(AnalogPin.P1);" line57="" line58="        pulseMinLocal += (1024 - pulseMinLocal) * pulseMotion;" line59="        if (pulseLocal &lt; pulseMinLocal)" line60="            pulseMinLocal = pulseLocal;" line61="" line62="        pulseMaxLocal -= pulseMaxLocal * pulseMotion;" line63="        if (pulseLocal &gt; pulseMaxLocal)" line64="            pulseMaxLocal = pulseLocal;" line65="" line66="        let range2 = pulseMaxLocal - pulseMinLocal;" line67="" line68="        let output2 = 0;" line69="" line70="        if (range2 &gt; 0) {" line71="            output2 = 1024 * (pulseLocal - pulseMinLocal) / range2;" line72="        }" line73="" line74="        return output2;    " line75="    }" line76="" line77="/*" line78="    //% block=&quot;read pulse max&quot;" line79="    //% group=&quot;Pulse&quot;" line80="    export function pulseSensorRangeMax(): number { return pulseMaxLocal; }" line81="" line82="    //% block=&quot;read pulse min&quot;" line83="    //% group=&quot;Pulse&quot;" line84="    export function pulseSensorRangeMin(): number { return pulseMinLocal; }" line85="*/" line86="" line87="    // For all LED functions" line88="    // Packing into number:  ( r &lt;&lt; 16 ) | (g &lt;&lt; 8 ) | b" line89="    // Sending to ws2812   ---b---g---r---&gt;" line90="    // Added some text to pxt.json to disable BT " line91="    // this helps with console output!" line92="" line93="    //% block=&quot;set Left Earring, Right Earring, Necklace $leftEar | $rightEar | $necklace&quot;" line94="    //% group=&quot;Accessories&quot;" line95="    //% leftEar.shadow=&quot;colorNumberPicker&quot;" line96="    //% rightEar.shadow=&quot;colorNumberPicker&quot;" line97="    //% necklace.shadow=&quot;colorNumberPicker&quot;" line98="    export function ledAccessories(leftEar: number, rightEar: number, necklace: number ) {" line99="        let e = pins.createBuffer(13 * 3)" line100="        let offset = 0;" line101="" line102="        // Left Ear" line103="" line104="        let rColor = (leftEar &gt;&gt; 16) &amp; 0xFF;" line105="        let gColor = (leftEar &gt;&gt; 8) &amp; 0xFF;" line106="        let bColor = (leftEar &gt;&gt; 0) &amp; 0xFF;" line107="" line108="        e[offset + 0] = gColor;" line109="        e[offset + 1] = rColor;" line110="        e[offset + 2] = bColor;" line111="" line112="        // Right Ear" line113="" line114="        offset += 3;" line115="" line116="        rColor = (rightEar &gt;&gt; 16) &amp; 0xFF;" line117="        gColor = (rightEar &gt;&gt; 8) &amp; 0xFF;" line118="        bColor = (rightEar &gt;&gt; 0) &amp; 0xFF;" line119="" line120="        e[offset + 0] = gColor;" line121="        e[offset + 1] = rColor;" line122="        e[offset + 2] = bColor;" line123="" line124="        // Necklace" line125="" line126="        for ( let i = 0; i &lt; 11; i++ ) { " line127="            offset += 3;" line128="" line129="            rColor = (necklace &gt;&gt; 16) &amp; 0xFF;" line130="            gColor = (necklace &gt;&gt; 8) &amp; 0xFF;" line131="            bColor = (necklace &gt;&gt; 0) &amp; 0xFF;" line132="" line133="            e[offset + 0] = gColor;" line134="            e[offset + 1] = rColor;" line135="            e[offset + 2] = bColor;" line136="        }" line137="        " line138="        // Zip all the colors out" line139="" line140="        ws2812b.sendBuffer(e, DigitalPin.P16);" line141="    }" line142="" line143="    //% block=&quot;set Accessory $accessory&quot;" line144="    //% group=&quot;Accessories&quot;" line145="    //% accessory.shadow=&quot;colorNumberPicker&quot;" line146="    export function ledAccessory(accessory: number) {" line147="        let f = pins.createBuffer(12 * 3)" line148="        let offset2 = 0;" line149="" line150="        // Accessory" line151="        let rColor2;" line152="        let gColor2;" line153="        let bColor2;" line154="" line155="        for (let j = 0; j &lt; 12; j++) {" line156="            rColor2 = (accessory &gt;&gt; 16) &amp; 0xFF;" line157="            gColor2 = (accessory &gt;&gt; 8) &amp; 0xFF;" line158="            bColor2 = (accessory &gt;&gt; 0) &amp; 0xFF;" line159="" line160="            f[offset2 + 0] = gColor2;" line161="            f[offset2 + 1] = rColor2;" line162="            f[offset2 + 2] = bColor2;" line163="" line164="            offset2 += 3;" line165="        }" line166="" line167="        // Zip all the colors out" line168="" line169="        ws2812b.sendBuffer(f, DigitalPin.P16);" line170="    }" line171="" line172="" line173="    //% block=&quot;set ring led $cv&quot;" line174="    //% group=&quot;Ring&quot;" line175="    //% cv.shadow=&quot;colorNumberPicker&quot;" line176="    export function ringDirect(cv: number) {" line177="        let g = pins.createBuffer(25 * 3)" line178="" line179="        let rColor22 = (cv &gt;&gt; 16) &amp; 0xFF;" line180="        let gColor22 = (cv &gt;&gt; 8) &amp; 0xFF;" line181="        let bColor22 = (cv &gt;&gt; 0) &amp; 0xFF;" line182="" line183="        for (let k = 0; k &lt; 25; k++) {" line184="            g[k * 3 + 0] = gColor22;" line185="            g[k * 3 + 1] = rColor22;" line186="            g[k * 3 + 2] = bColor22;" line187="        }" line188="        // ws2812b.setBufferMode(DigitalPin.P8, ws2812b.BUFFER_MODE_RGB );" line189="        ws2812b.sendBuffer(g, DigitalPin.P8);" line190="    }" line191="" line192="    //% block" line193="    //% group=&quot;Distance&quot;" line194="    export function distance(): number {" line195="        let trig = DigitalPin.P1;" line196="        let echo = DigitalPin.P2;" line197="        let maxCMDistance = 100 * 58;" line198="" line199="        pins.setPull(trig, PinPullMode.PullNone);" line200="        pins.digitalWritePin(trig, 0);" line201="        control.waitMicros(2);" line202="        pins.digitalWritePin(trig, 1);" line203="        control.waitMicros(10);" line204="        pins.digitalWritePin(trig, 0);" line205="" line206="        // read pulse" line207="        const d = pins.pulseIn(echo, PulseValue.High, maxCMDistance);" line208="" line209="        return Math.idiv(d, 58);" line210="    }" line211="" line212="    //% block" line213="    //% group=&quot;Soil Moisture&quot;" line214="    export function soilMoisture(): number {" line215="" line216="        // Read analog value from soil moisture sensor" line217="        const moistureLevel = pins.analogReadPin(AnalogPin.P1);" line218="" line219="        // Map to a percentage (0-100%)" line220="        const minValue = 0;   // dry soil" line221="        const maxValue = 1023; // wet soil" line222="        const percentage = Math.map(moistureLevel, minValue, maxValue, 0, 100);" line223="" line224="        // Return percentage" line225="        return Math.constrain(percentage, 0, 100);" line226="    }" line227="" line228="" line229="    // " line230="" line231="    let colorSensorConfigured: boolean = false;" line232="    let colorSensorAddress: number = 0x39;" line233="    let colorSensorEnableRegister: number = 0x80;" line234="    let colorSensorATimeRegister: number = 0x81;" line235="    let colorSensorWTimeRegister: number = 0x83;" line236="    let colorSensorPersRegister: number = 0x8C;" line237="    let colorSensorAGainRegister: number = 0x8F;" line238="    let colorSensorIdRegister: number = 0x92;" line239="    let colorSensorStatusRegister: number = 0x93;" line240="    let colorSensorRedRegister: number = 0x96;" line241="    let colorSensorGreenRegister: number = 0x98;" line242="    let colorSensorBlueRegister: number = 0x9A;" line243="" line244="    let colorSensorId: number = 0x90;" line245="" line246="    //% block" line247="    //% group=&quot;ColorSensor&quot;" line248="    export function checkColorSensor(): boolean {" line249="        let id3 = i2cReadRegister8(colorSensorAddress, colorSensorIdRegister);" line250="        // basic.showNumber( id )" line251="        return (id3 == colorSensorId)" line252="    }" line253="" line254="    export function colorSensorReadId(): number {" line255="        let id32 = i2cReadRegister8(colorSensorAddress, colorSensorIdRegister);" line256="        // basic.showNumber( id )" line257="        return id32;" line258="    }" line259="" line260="    export function colorSensorReadStatus(): number {" line261="        let status = i2cReadRegister8(colorSensorAddress, colorSensorStatusRegister);" line262="        // basic.showNumber( id )" line263="        return status;" line264="    }" line265="" line266="    export function colorSensorReadEnable(): number {" line267="        let status2 = i2cReadRegister8(colorSensorAddress, colorSensorEnableRegister);" line268="        // basic.showNumber( id )" line269="        return status2;" line270="    }" line271="" line272="    //% block" line273="    //% group=&quot;ColorSensor&quot;" line274="    export function colorSensorRead(): number {" line275="        let rSense: number = 0;" line276="        let bSense: number = 0;" line277="        let gSense: number = 0;" line278="" line279="        colorSensorConfigure();" line280="" line281="        if (colorSensorConfigured) {" line282="            rSense = i2cReadRegister16(colorSensorAddress, colorSensorRedRegister);" line283="            gSense = i2cReadRegister16(colorSensorAddress, colorSensorGreenRegister);" line284="            bSense = i2cReadRegister16(colorSensorAddress, colorSensorBlueRegister);" line285="        }" line286="" line287="        let punchup = 3;  // 2.5 worked for a while - too washed out?" line288="" line289="        let rColor222 = (rSense &gt;&gt; 8) &amp; 0xFF;" line290="        let gColor222 = (gSense &gt;&gt; 8) &amp; 0xFF;" line291="        let bColor222 = (bSense &gt;&gt; 8) &amp; 0xFF;" line292="" line293="        rColor222 = Math.pow(rColor222, punchup );" line294="        gColor222 = Math.pow(gColor222, punchup );" line295="        bColor222 = Math.pow(bColor222, punchup );" line296="" line297="        let cMax = (rColor222 &gt; gColor222) ? rColor222 : gColor222;" line298="        cMax = (bColor222 &gt; cMax) ? bColor222 : cMax;" line299="" line300="        rColor222 = 16 * rColor222 / cMax;" line301="        gColor222 = 16 * gColor222 / cMax;" line302="        bColor222 = 16 * bColor222 / cMax;" line303="" line304="        // basic.showNumber( rColor &gt;&gt; 4 );" line305="" line306="        return (rColor222 &lt;&lt; 16) | (gColor222 &lt;&lt; 8) | bColor222;" line307="        // return (rSense &lt;&lt; 16) | (gSense &lt;&lt; 8) | bSense;" line308="" line309="    }" line310="" line311="    //% block" line312="    //% group=&quot;ColorSensor&quot;" line313="    export function colorGetRed(color: number): number {" line314="        return (color &gt;&gt; 16) &amp; 0xFF;" line315="    }" line316="" line317="    //% block" line318="    //% group=&quot;ColorSensor&quot;" line319="    export function colorGetGreen(color: number): number {" line320="        return (color &gt;&gt; 8) &amp; 0xFF;" line321="    }" line322="" line323="    //% block" line324="    //% group=&quot;ColorSensor&quot;" line325="    export function colorGetBlue(color: number): number {" line326="        return (color &amp; 0xFF);" line327="    }" line328="" line329="    function colorSensorConfigure() {" line330="        if (!colorSensorConfigured &amp;&amp; checkColorSensor()) {" line331="            // turn it on" line332="            // Control Reg:  PON" line333="            i2cWriteRegister(colorSensorAddress, colorSensorEnableRegister, 0x01)" line334="" line335="            basic.pause(100)" line336="" line337="            // ATime  :RGB TIMING:FF 2.4ms, C0 150ms" line338="            i2cWriteRegister(colorSensorAddress, colorSensorATimeRegister, 0xC0)" line339="            // Wait Time:FF 2.4ms" line340="            i2cWriteRegister(colorSensorAddress, colorSensorWTimeRegister, 0xFF)" line341="            // Persistance: 0x00 - IRQ every time" line342="            i2cWriteRegister(colorSensorAddress, colorSensorPersRegister, 0)" line343="            // AGain: 0 - 3" line344="            i2cWriteRegister(colorSensorAddress, colorSensorAGainRegister, 3)" line345="" line346="            // Control Reg:  PON AEN" line347="            i2cWriteRegister(colorSensorAddress, colorSensorEnableRegister, 0x08 | 0x03)" line348="            basic.pause(100)" line349="" line350="" line351="            //            basic.showString( &quot;C&quot;);" line352="            colorSensorConfigured = true;" line353="        }" line354="    }" line355="" line356="    export function i2cReadRegister8(address: number, register: number): number {" line357="        pins.i2cWriteNumber(" line358="            address," line359="            register," line360="            NumberFormat.UInt8LE," line361="            true" line362="        )" line363="        return pins.i2cReadNumber(address, NumberFormat.UInt8LE, false)" line364="    }" line365="" line366="    export function i2cReadRegister16(address: number, register: number): number {" line367="        pins.i2cWriteNumber(" line368="            address," line369="            register," line370="            NumberFormat.UInt8LE," line371="            true" line372="        )" line373="        return pins.i2cReadNumber(address, NumberFormat.UInt16LE, false)" line374="    }" line375="" line376="    export function i2cWriteRegister8_8(address: number, register: number, value: number) {" line377="        pins.i2cWriteNumber(" line378="            address," line379="            register," line380="            NumberFormat.UInt8LE," line381="            true" line382="        )" line383="        pins.i2cWriteNumber(address, value, NumberFormat.UInt8LE, false)" line384="    }" line385="" line386="    export function i2cWriteRegister(address: number, register: number, value: number) {" line387="        pins.i2cWriteNumber(" line388="            address," line389="            register | (value &lt;&lt; 8)," line390="            NumberFormat.UInt16LE," line391="            false" line392="        )" line393="        // pins.i2cWriteNumber(address, value, NumberFormat.UInt8LE, false)" line394="    }" line395="" line396="}" numlines="397"></mutation></block></statement></block></xml>