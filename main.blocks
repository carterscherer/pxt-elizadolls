<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="3;qUs%nl{P_d%kkuCFw$" x="39" y="20"><statement name="HANDLER"><block type="typescript_statement" id="{6Y4!$~_01u+[Bj[!8[D"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace ElizaDolls {" line1="" line2="    // In case it gets lost from above (// then %) " line3="    //  % color=&quot;#FE99F8&quot;" line4="" line5="    let pulseMinLocal = 1024;" line6="    let pulseMaxLocal = 0;" line7="    let pulseLocal = 0;" line8="    let pulseMotion = 0.001;" line9="" line10="    //% block=&quot;read beat&quot;" line11="    //% group=&quot;Pulse&quot;" line12="    export function pulseSensorBeat( ) : boolean {" line13="" line14="        pulseLocal = pins.analogReadPin( AnalogPin.P1 );" line15="" line16="        pulseMinLocal += ( 1024 - pulseMinLocal ) * pulseMotion;" line17="        if (pulseLocal &lt; pulseMinLocal )" line18="            pulseMinLocal = pulseLocal;" line19="" line20="        pulseMaxLocal -= pulseMaxLocal * pulseMotion;" line21="        if (pulseLocal &gt; pulseMaxLocal)" line22="            pulseMaxLocal = pulseLocal;" line23="" line24="        let range = pulseMaxLocal - pulseMinLocal;" line25="" line26="        let output = false;" line27="" line28="        if ( range &gt; 0 ) {" line29="            if ( ( pulseLocal - pulseMinLocal ) &gt; 3 * range / 4 )" line30="                output = true;" line31="        }" line32="" line33="        return output;" line34="    }" line35="" line36="    let pulseSensorBpmBeat = false;" line37="    let pulseSensorBpmRunningTime = 0;" line38="    let pulseSensorBpmStore = 0;" line39="" line40="    //% block=&quot;read pulse BPM&quot;" line41="    //% group=&quot;Pulse&quot;" line42="    export function pulseSensorBpm(): number {" line43="        let beat = pulseSensorBeat();" line44="        if ( beat &amp;&amp; ( beat != pulseSensorBpmBeat ) ) {" line45="            let runningTime = input.runningTime();" line46="            pulseSensorBpmStore = 60000 / ( runningTime - pulseSensorBpmRunningTime );" line47="            pulseSensorBpmRunningTime = runningTime;" line48="        }" line49="        pulseSensorBpmBeat = beat;" line50="        return pulseSensorBpmStore;" line51="    }" line52="" line53="    //% block=&quot;read pulse wave&quot;" line54="    //% group=&quot;Pulse&quot;" line55="    export function pulseSensorWave(): number { " line56="        pulseLocal = pins.analogReadPin(AnalogPin.P1);" line57="" line58="        pulseMinLocal += (1024 - pulseMinLocal) * pulseMotion;" line59="        if (pulseLocal &lt; pulseMinLocal)" line60="            pulseMinLocal = pulseLocal;" line61="" line62="        pulseMaxLocal -= pulseMaxLocal * pulseMotion;" line63="        if (pulseLocal &gt; pulseMaxLocal)" line64="            pulseMaxLocal = pulseLocal;" line65="" line66="        let range2 = pulseMaxLocal - pulseMinLocal;" line67="" line68="        let output2 = 0;" line69="" line70="        if (range2 &gt; 0) {" line71="            output2 = 1024 * (pulseLocal - pulseMinLocal) / range2;" line72="        }" line73="" line74="        return output2;    " line75="    }" line76="" line77="/*" line78="    //% block=&quot;read pulse max&quot;" line79="    //% group=&quot;Pulse&quot;" line80="    export function pulseSensorRangeMax(): number { return pulseMaxLocal; }" line81="" line82="    //% block=&quot;read pulse min&quot;" line83="    //% group=&quot;Pulse&quot;" line84="    export function pulseSensorRangeMin(): number { return pulseMinLocal; }" line85="*/" line86="" line87="    // For all LED functions" line88="    // Packing into number:  ( r &lt;&lt; 16 ) | (g &lt;&lt; 8 ) | b" line89="    // Sending to ws2812   ---b---g---r---&gt;" line90="    // Added some text to pxt.json to disable BT " line91="    // this helps with console output!" line92="" line93="    //% block=&quot;set Left Earring, Right Earring, Necklace $leftEar | $rightEar | $necklace&quot;" line94="    //% group=&quot;Accessories&quot;" line95="    //% leftEar.shadow=&quot;colorNumberPicker&quot;" line96="    //% rightEar.shadow=&quot;colorNumberPicker&quot;" line97="    //% necklace.shadow=&quot;colorNumberPicker&quot;" line98="    export function ledAccessories(leftEar: number, rightEar: number, necklace: number ) {" line99="        let e = pins.createBuffer(13 * 3)" line100="        let offset = 0;" line101="" line102="        // Left Ear" line103="" line104="        let rColor = (leftEar &gt;&gt; 16) &amp; 0xFF;" line105="        let gColor = (leftEar &gt;&gt; 8) &amp; 0xFF;" line106="        let bColor = (leftEar &gt;&gt; 0) &amp; 0xFF;" line107="" line108="        e[offset + 0] = gColor;" line109="        e[offset + 1] = rColor;" line110="        e[offset + 2] = bColor;" line111="" line112="        // Right Ear" line113="" line114="        offset += 3;" line115="" line116="        rColor = (rightEar &gt;&gt; 16) &amp; 0xFF;" line117="        gColor = (rightEar &gt;&gt; 8) &amp; 0xFF;" line118="        bColor = (rightEar &gt;&gt; 0) &amp; 0xFF;" line119="" line120="        e[offset + 0] = gColor;" line121="        e[offset + 1] = rColor;" line122="        e[offset + 2] = bColor;" line123="" line124="        // Necklace" line125="" line126="        for ( let i = 0; i &lt; 11; i++ ) { " line127="            offset += 3;" line128="" line129="            rColor = (necklace &gt;&gt; 16) &amp; 0xFF;" line130="            gColor = (necklace &gt;&gt; 8) &amp; 0xFF;" line131="            bColor = (necklace &gt;&gt; 0) &amp; 0xFF;" line132="" line133="            e[offset + 0] = gColor;" line134="            e[offset + 1] = rColor;" line135="            e[offset + 2] = bColor;" line136="        }" line137="        " line138="        // Zip all the colors out" line139="" line140="        ws2812b.sendBuffer(e, DigitalPin.P16);" line141="    }" line142="" line143="    //% block=&quot;set Accessory $accessory&quot;" line144="    //% group=&quot;Accessories&quot;" line145="    //% accessory.shadow=&quot;colorNumberPicker&quot;" line146="    export function ledAccessory(accessory: number) {" line147="        let f = pins.createBuffer(12 * 3)" line148="        let offset2 = 0;" line149="" line150="        // Accessory" line151="        let rColor2;" line152="        let gColor2;" line153="        let bColor2;" line154="" line155="        for (let j = 0; j &lt; 12; j++) {" line156="            rColor2 = (accessory &gt;&gt; 16) &amp; 0xFF;" line157="            gColor2 = (accessory &gt;&gt; 8) &amp; 0xFF;" line158="            bColor2 = (accessory &gt;&gt; 0) &amp; 0xFF;" line159="" line160="            f[offset2 + 0] = gColor2;" line161="            f[offset2 + 1] = rColor2;" line162="            f[offset2 + 2] = bColor2;" line163="" line164="            offset2 += 3;" line165="        }" line166="" line167="        // Zip all the colors out" line168="" line169="        ws2812b.sendBuffer(f, DigitalPin.P16);" line170="    }" line171="" line172="" line173="    //% block=&quot;set ring led $cv&quot;" line174="    //% group=&quot;Ring&quot;" line175="    //% cv.shadow=&quot;colorNumberPicker&quot;" line176="    export function ringDirect(cv: number) {" line177="        let g = pins.createBuffer(25 * 3)" line178="" line179="        let rColor22 = (cv &gt;&gt; 16) &amp; 0xFF;" line180="        let gColor22 = (cv &gt;&gt; 8) &amp; 0xFF;" line181="        let bColor22 = (cv &gt;&gt; 0) &amp; 0xFF;" line182="" line183="        for (let k = 0; k &lt; 25; k++) {" line184="            g[k * 3 + 0] = gColor22;" line185="            g[k * 3 + 1] = rColor22;" line186="            g[k * 3 + 2] = bColor22;" line187="        }" line188="        // ws2812b.setBufferMode(DigitalPin.P8, ws2812b.BUFFER_MODE_RGB );" line189="        ws2812b.sendBuffer(g, DigitalPin.P8);" line190="    }" line191="" line192="    //% block=&quot;Animated Rainbow Ring $cv&quot;" line193="    //% group=&quot;Ring&quot;" line194="    //% cv.shadow=&quot;colorNumberPicker&quot;" line195="    export function ringDirectRainbow() {" line196="        let h = pins.createBuffer(25 * 3); // 25 LEDs, each with 3 bytes (RGB)" line197="" line198="        for (let l = 0; l &lt; 255; l++) {" line199="            for (let m = 0; m &lt; 25; m++) {" line200="                // Create a wave effect by varying the colors across the LEDs" line201="                let rColor3 = (l + m * 10) % 50; // Red shifts slightly per LED" line202="                let gColor3 = (l + m * 20) % 50; // Green shifts faster" line203="                let bColor3 = (l + m * 30) % 50; // Blue shifts even faster" line204="" line205="                // Assign the colors to the buffer" line206="                h[m * 3 + 0] = gColor3; // G" line207="                h[m * 3 + 1] = rColor3; // R" line208="                h[m * 3 + 2] = bColor3; // B" line209="            }" line210="" line211="            // Send the buffer to the LEDs" line212="            ws2812b.sendBuffer(h, DigitalPin.P8);" line213="" line214="            // Simple delay to slow down the animation" line215="            basic.pause(100); // Adjust the pause duration to change speed" line216="        }" line217="    }" line218="" line219="" line220="" line221="    //% block" line222="    //% group=&quot;Distance Read Bear&quot;" line223="    export function distance(): number {" line224="        let trig = DigitalPin.P1;" line225="        let echo = DigitalPin.P2;" line226="        let maxCMDistance = 100 * 58;" line227="" line228="        pins.setPull(trig, PinPullMode.PullNone);" line229="        pins.digitalWritePin(trig, 0);" line230="        control.waitMicros(2);" line231="        pins.digitalWritePin(trig, 1);" line232="        control.waitMicros(10);" line233="        pins.digitalWritePin(trig, 0);" line234="" line235="        // read pulse" line236="        const d = pins.pulseIn(echo, PulseValue.High, maxCMDistance);" line237="" line238="        return Math.idiv(d, 58);" line239="    }" line240="" line241="    //% block" line242="    //% group=&quot;Plant Happiness Carrot&quot;" line243="    export function soilMoistureRead(): number {" line244="        const SOIL_SENSOR_ADDRESS = 0x36; // Default I2C address for the STEMMA Soil Sensor" line245="        const TOUCH_BASE = 0x0F; // Base register for moisture" line246="        const TOUCH_OFFSET = 0x10; // Offset for moisture reading" line247="" line248="        let buffer = pins.createBuffer(2);" line249="" line250="        // Write command to the sensor" line251="        buffer[0] = TOUCH_BASE;" line252="        buffer[1] = TOUCH_OFFSET;" line253="        pins.i2cWriteBuffer(SOIL_SENSOR_ADDRESS, buffer, false);" line254="" line255="        // Small delay before reading" line256="        pause(5);" line257="" line258="        // Read moisture level (16-bit value)" line259="        buffer = pins.i2cReadBuffer(SOIL_SENSOR_ADDRESS, 2, false);" line260="        let moistureLevel = (buffer[0] &lt;&lt; 8) | buffer[1]; // Convert to 16-bit integer" line261="" line262="        // Additional delay to prevent excessive I2C reads" line263="        pause(250);" line264="" line265="        return moistureLevel;" line266="    }" line267="" line268="    //% block" line269="    //% group=&quot;Read Color Flower&quot;" line270="    export function newColorSensor(): { red: number; green: number; blue: number; white: number } {" line271="        const COLOR_SENSOR_ADDRESS = 0x10; // I2C address for VEML6040" line272="        const RED_REG = 0x08; // Register for red " line273="        const GREEN_REG = 0x09; // Register for green " line274="        const BLUE_REG = 0x0A; // Register for blue " line275="        const WHITE_REG = 0x0B; // Register for white " line276="" line277="        function readRegister(register: number): number {" line278="            let buffer2 = pins.createBuffer(1);" line279="            buffer2[0] = register;" line280="            pins.i2cWriteBuffer(COLOR_SENSOR_ADDRESS, buffer2, false);" line281="            pause(5); // Small delay before reading" line282="            buffer2 = pins.i2cReadBuffer(COLOR_SENSOR_ADDRESS, 2, false);" line283="            return ((buffer2[1] &lt;&lt; 8) | buffer2[0]); // Fix byte order" line284="        }" line285="" line286="        let red = readRegister(RED_REG);" line287="        let green = readRegister(GREEN_REG);" line288="        let blue = readRegister(BLUE_REG);" line289="        let white = readRegister(WHITE_REG);" line290="" line291="        pause(250);" line292="" line293="        return { red, green, blue, white };" line294="    }" line295="" line296="    // scale 16-bit to 8-bit" line297="    function scaleColor(value: number): number {" line298="        return Math.map(value, 0, 65535, 0, 255);" line299="    }" line300="" line301="    //% block" line302="    //% group=&quot;Set Ring To Color Flower&quot;" line303="    export function setRingFlowerColor() {" line304="        let color = newColorSensor();" line305="" line306="        let n = pins.createBuffer(25 * 3);" line307="" line308="        for (let o = 0; o &lt; 25; o++) {" line309="            n[o * 3 + 0] = scaleColor(color.green); // Green" line310="            n[o * 3 + 1] = scaleColor(color.red);   // Red" line311="            n[o * 3 + 2] = scaleColor(color.blue);  // Blue" line312="        }" line313="" line314="        basic.pause(50); " line315="        ws2812b.sendBuffer(n, DigitalPin.P8);" line316="    }" line317="" line318="" line319="" line320="    //% block" line321="    //% group=&quot;A0 Soil Moisture&quot;" line322="    // export function soilMoisture(): number {" line323="    //     let moistureLevel: number = 0;" line324="    //     // Read the analog value from the soil moisture sensor on AnalogPin.P0" line325="    //     moistureLevel = pins.analogReadPin(AnalogPin.P0);" line326="" line327="    //     return moistureLevel; // Return the current moisture level" line328="    // }" line329="" line330="" line331="        // const minValue = 0;   " line332="        // const maxValue = 1023; " line333="        // const percentage = Math.map(moistureLevel, minValue, maxValue, 0, 100);" line334="" line335="        // // Return the moisture percentage" line336="        // return Math.constrain(percentage, 0, 100);" line337="" line338="    // //% block" line339="    // //% group=&quot;Digital Soil Moisture&quot;" line340="    // export function soilMoistureDigital(): number {" line341="    //     // Read the analog value from the soil moisture sensor on AnalogPin.P1" line342="    //     const moistureLevel = pins.digitalReadPin(DigitalPin.P1);" line343="    //     const moistureLevelTwo = pins.digitalReadPin(DigitalPin.P2);" line344="" line345="    //     // Optionally, you can map the moisture level to a percentage (0-100%)" line346="    //     const minValue = 0;   // Adjust this based on your sensor's calibration for dry soil" line347="    //     const maxValue = 1023; // Adjust this based on your sensor's calibration for wet soil" line348="    //     const percentage = Math.map(moistureLevel, minValue, maxValue, 0, 100);" line349="" line350="    //     // Return the moisture percentage" line351="    //     return Math.constrain(percentage, 0, 100);" line352="    // }" line353="" line354="" line355="    // " line356="" line357="    let colorSensorConfigured: boolean = false;" line358="    let colorSensorAddress: number = 0x39;" line359="    let colorSensorEnableRegister: number = 0x80;" line360="    let colorSensorATimeRegister: number = 0x81;" line361="    let colorSensorWTimeRegister: number = 0x83;" line362="    let colorSensorPersRegister: number = 0x8C;" line363="    let colorSensorAGainRegister: number = 0x8F;" line364="    let colorSensorIdRegister: number = 0x92;" line365="    let colorSensorStatusRegister: number = 0x93;" line366="    let colorSensorRedRegister: number = 0x96;" line367="    let colorSensorGreenRegister: number = 0x98;" line368="    let colorSensorBlueRegister: number = 0x9A;" line369="" line370="    let colorSensorId: number = 0x90;" line371="" line372="    //% block" line373="    //% group=&quot;ColorSensor&quot;" line374="    export function checkColorSensor(): boolean {" line375="        let id3 = i2cReadRegister8(colorSensorAddress, colorSensorIdRegister);" line376="        // basic.showNumber( id )" line377="        return (id3 == colorSensorId)" line378="    }" line379="" line380="    export function colorSensorReadId(): number {" line381="        let id32 = i2cReadRegister8(colorSensorAddress, colorSensorIdRegister);" line382="        // basic.showNumber( id )" line383="        return id32;" line384="    }" line385="" line386="    export function colorSensorReadStatus(): number {" line387="        let status = i2cReadRegister8(colorSensorAddress, colorSensorStatusRegister);" line388="        // basic.showNumber( id )" line389="        return status;" line390="    }" line391="" line392="    export function colorSensorReadEnable(): number {" line393="        let status2 = i2cReadRegister8(colorSensorAddress, colorSensorEnableRegister);" line394="        // basic.showNumber( id )" line395="        return status2;" line396="    }" line397="" line398="    //% block" line399="    //% group=&quot;ColorSensor&quot;" line400="    export function colorSensorRead(): number {" line401="        let rSense: number = 0;" line402="        let bSense: number = 0;" line403="        let gSense: number = 0;" line404="" line405="        colorSensorConfigure();" line406="" line407="        if (colorSensorConfigured) {" line408="            rSense = i2cReadRegister16(colorSensorAddress, colorSensorRedRegister);" line409="            gSense = i2cReadRegister16(colorSensorAddress, colorSensorGreenRegister);" line410="            bSense = i2cReadRegister16(colorSensorAddress, colorSensorBlueRegister);" line411="        }" line412="" line413="        let punchup = 3;  // 2.5 worked for a while - too washed out?" line414="" line415="        let rColor222 = (rSense &gt;&gt; 8) &amp; 0xFF;" line416="        let gColor222 = (gSense &gt;&gt; 8) &amp; 0xFF;" line417="        let bColor222 = (bSense &gt;&gt; 8) &amp; 0xFF;" line418="" line419="        rColor222 = Math.pow(rColor222, punchup );" line420="        gColor222 = Math.pow(gColor222, punchup );" line421="        bColor222 = Math.pow(bColor222, punchup );" line422="" line423="        let cMax = (rColor222 &gt; gColor222) ? rColor222 : gColor222;" line424="        cMax = (bColor222 &gt; cMax) ? bColor222 : cMax;" line425="" line426="        rColor222 = 16 * rColor222 / cMax;" line427="        gColor222 = 16 * gColor222 / cMax;" line428="        bColor222 = 16 * bColor222 / cMax;" line429="" line430="        // basic.showNumber( rColor &gt;&gt; 4 );" line431="" line432="        return (rColor222 &lt;&lt; 16) | (gColor222 &lt;&lt; 8) | bColor222;" line433="        // return (rSense &lt;&lt; 16) | (gSense &lt;&lt; 8) | bSense;" line434="" line435="    }" line436="" line437="    //% block" line438="    //% group=&quot;ColorSensor&quot;" line439="    export function colorGetRed(color: number): number {" line440="        return (color &gt;&gt; 16) &amp; 0xFF;" line441="    }" line442="" line443="    //% block" line444="    //% group=&quot;ColorSensor&quot;" line445="    export function colorGetGreen(color: number): number {" line446="        return (color &gt;&gt; 8) &amp; 0xFF;" line447="    }" line448="" line449="    //% block" line450="    //% group=&quot;ColorSensor&quot;" line451="    export function colorGetBlue(color: number): number {" line452="        return (color &amp; 0xFF);" line453="    }" line454="" line455="    function colorSensorConfigure() {" line456="        if (!colorSensorConfigured &amp;&amp; checkColorSensor()) {" line457="            // turn it on" line458="            // Control Reg:  PON" line459="            i2cWriteRegister(colorSensorAddress, colorSensorEnableRegister, 0x01)" line460="" line461="            basic.pause(100)" line462="" line463="            // ATime  :RGB TIMING:FF 2.4ms, C0 150ms" line464="            i2cWriteRegister(colorSensorAddress, colorSensorATimeRegister, 0xC0)" line465="            // Wait Time:FF 2.4ms" line466="            i2cWriteRegister(colorSensorAddress, colorSensorWTimeRegister, 0xFF)" line467="            // Persistance: 0x00 - IRQ every time" line468="            i2cWriteRegister(colorSensorAddress, colorSensorPersRegister, 0)" line469="            // AGain: 0 - 3" line470="            i2cWriteRegister(colorSensorAddress, colorSensorAGainRegister, 3)" line471="" line472="            // Control Reg:  PON AEN" line473="            i2cWriteRegister(colorSensorAddress, colorSensorEnableRegister, 0x08 | 0x03)" line474="            basic.pause(100)" line475="" line476="" line477="            //            basic.showString( &quot;C&quot;);" line478="            colorSensorConfigured = true;" line479="        }" line480="    }" line481="" line482="    export function i2cReadRegister8(address: number, register: number): number {" line483="        pins.i2cWriteNumber(" line484="            address," line485="            register," line486="            NumberFormat.UInt8LE," line487="            true" line488="        )" line489="        return pins.i2cReadNumber(address, NumberFormat.UInt8LE, false)" line490="    }" line491="" line492="    export function i2cReadRegister16(address: number, register: number): number {" line493="        pins.i2cWriteNumber(" line494="            address," line495="            register," line496="            NumberFormat.UInt8LE," line497="            true" line498="        )" line499="        return pins.i2cReadNumber(address, NumberFormat.UInt16LE, false)" line500="    }" line501="" line502="" line503="" line504="    export function i2cWriteRegister8_8(address: number, register: number, value: number) {" line505="        pins.i2cWriteNumber(" line506="            address," line507="            register," line508="            NumberFormat.UInt8LE," line509="            true" line510="        )" line511="        pins.i2cWriteNumber(address, value, NumberFormat.UInt8LE, false)" line512="    }" line513="" line514="    export function i2cWriteRegister(address: number, register: number, value: number) {" line515="        pins.i2cWriteNumber(" line516="            address," line517="            register | (value &lt;&lt; 8)," line518="            NumberFormat.UInt16LE," line519="            false" line520="        )" line521="        // pins.i2cWriteNumber(address, value, NumberFormat.UInt8LE, false)" line522="    }" line523="" line524="}" numlines="525"></mutation></block></statement></block></xml>